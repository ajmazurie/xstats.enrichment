#!/usr/bin/env python

import optparse, sys, os

p = optparse.OptionParser()

p.add_option("-l", "--list", dest = "list_fn", metavar = "FILENAME",
	help = "Ranked list of objects")

p.add_option("-s", "--subset", dest = "subset_fn", metavar = "FILENAME",
	help = "Subset of objects")

p.add_option("-S", "--population-size", type = "int", dest = "population_size", metavar = "INTEGER",
	help = "Size of the population (-s/--subset option)")

p.add_option("-a", "--annotations", dest = "annotations_fn", metavar = "FILENAME",
	help = "Objects annotations, as a tab-delimited text file")

p.add_option("-o", "--output", dest = "output_fn", metavar = "FILENAME",
	help = "Output file (default: stdout)")

(p, a) = p.parse_args()

def error (msg):
	print >>sys.stderr, "ERROR: %s" % msg
	print >>sys.stderr, "Use --help for a list of options."
	sys.exit(1)

if (p.list_fn) and (not os.path.exists(p.list_fn)):
	error("unable to open '%s'" % p.list_fn)

if (p.subset_fn) and (not os.path.exists(p.subset_fn)):
	error("unable to open '%s'" % p.subset_fn)

if ((not p.list_fn) and (not p.subset_fn)) or (p.list_fn and p.subset_fn):
	error("either a list or a subset of object must be provided")

if (p.subset_fn) and ((not p.population_size) or (p.population_size < 1)):
	error("a population size must be provided")

if (not p.annotations_fn):
	error("an annotation file must be provided")

if (not os.path.exists(p.annotations_fn)):
	error("unable to open '%s'" % p.annotations_fn)

if (not p.output_fn):
	p.output_fn = sys.stdout
else:
	p.output_fn = open(p.output_fn, 'w')
	print >>p.output_fn, "Property	P-value (uncorrected)	P-value (corrected)"

#:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

from stream import readline
import xpickle, xhash
import ui, enrichment, multiple_testing

print >>sys.stderr, "reading from '%s'" % p.annotations_fn

Object2Properties = {}
Property2Objects = {}

for data in readline(p.annotations_fn, split_by = '	'):
	object_id = data[0]
	for property in data[1:]:
		xhash.set(Object2Properties, (object_id, property))
		xhash.set(Property2Objects, (property, object_id))

print "  %s objects annotated with %s properties" % (len(Object2Properties), len(Property2Objects))

if (p.list_fn):
	print >>sys.stderr, "reading ranked list from '%s'" % p.list_fn

	list = []
	seen = {}
	for object_id in readline(p.list_fn):
		list.append(object_id)
		if (object_id in seen):
			error("the list contains duplicate entries")

		seen[object_id] = True

	print >>sys.stderr, "  %s objects" % len(list)

	occurrence = {}
	properties = {}

	for i, object_id in enumerate(list):
		for property in Object2Properties.get(object_id, []):
			if (not property in occurrence):
				occurrence[property] = [0 for n in range(len(list))]

			occurrence[property][i] = 1
			properties[property] = True

	properties = xhash.ordered_keys(properties)

	print >>sys.stderr, "  %s properties" % len(properties)

	if (len(properties) == 0):
		error("none of the object could be annotated")

	pb = ui.ProgressBar(len(properties), offset = 2, stream = sys.stderr)

	uncorrected_pvalues = []

	for i, property in enumerate(properties):
		p_value = enrichment.mHG(
			occurrence[property],
			B = len(Property2Objects[property]),
			N = len(list)
		)

		uncorrected_pvalues.append(p_value)
		pb.display(i)

	pb.clear()

	corrected_pvalues = multiple_testing.fdr(uncorrected_pvalues)

	for i, property in enumerate(properties):
		print >>p.output_fn, "%s	%s	%s" % (property, uncorrected_pvalues[i], corrected_pvalues[i])

	p.output_fn.close()

if (p.subset_fn):
	print >>sys.stderr, "reading subset from '%s'" % p.subset_fn

	subset = []
	seen = {}
	for object_id in readline(p.subset_fn):
		subset.append(object_id)
		if (object_id in seen):
			error("the subset contains duplicate entries")

		seen[object_id] = True

	n = len(subset)

	print >>sys.stderr, "  %s objects" % n

	N = p.population_size

	if (N < n):
		error("invalid population size: the subset is bigger than the value provided")

	b = {}

	for i, object_id in enumerate(subset):
		for property in Object2Properties.get(object_id, []):
			if (not property in b):
				b[property] = 0

			b[property] += 1

	properties = xhash.ordered_keys(b)

	print >>sys.stderr, "  %s properties" % len(properties)

	if (len(properties) == 0):
		error("none of the object could be annotated")

	pb = ui.ProgressBar(len(properties), offset = 2, stream = sys.stderr)

	uncorrected_pvalues = []

	for i, property in enumerate(properties):
		p_value = enrichment.fisher_exact_test(
			b = b[property],
			n = n,
			B = len(Property2Objects[property]),
			N = N
		)[2]

		uncorrected_pvalues.append(p_value)
		pb.display(i)

	pb.clear()

	corrected_pvalues = multiple_testing.fdr(uncorrected_pvalues)

	for i, property in enumerate(properties):
		print >>p.output_fn, "%s	%s	%s" % (property, uncorrected_pvalues[i], corrected_pvalues[i])

	p.output_fn.close()
